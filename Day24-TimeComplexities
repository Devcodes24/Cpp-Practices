Sorting Algorithms:

Bubble Sort: O(n^2)
Insertion Sort: O(n^2)
Merge Sort: O(n log n)
Quick Sort: O(n^2) in the worst case, O(n log n) on average
Heap Sort: O(n log n)
Searching Algorithms:

Linear Search: O(n)
Binary Search: O(log n)
Graph Algorithms:

Breadth-First Search (BFS): O(V + E) where V is the number of vertices and E is the number of edges.
Depth-First Search (DFS): O(V + E)
Dijkstra's Algorithm: O((V + E) * log V) using a binary heap for efficient priority queue
Bellman-Ford Algorithm: O(VE)
Floyd-Warshall Algorithm: O(V^3)
Dynamic Programming:

Fibonacci (naive recursion): O(2^n) - exponential
Fibonacci (dynamic programming): O(n)
Longest Common Subsequence (LCS): O(mn) where m and n are the lengths of the two sequences
Knapsack Problem: O(nW), where n is the number of items and W is the capacity of the knapsack.
Greedy Algorithms:

Kruskal's Algorithm (for Minimum Spanning Tree): O(E log V) where E is the number of edges and V is the number of vertices.
Prim's Algorithm (for Minimum Spanning Tree): O(V^2) with an adjacency matrix, O(E + V log V) with an adjacency list.
Divide and Conquer:

Strassen's Matrix Multiplication: O(n^log2(7)) - approximately O(n^2.81)
Closest Pair of Points: O(n log n)
Complexity Classes:

Polynomial time: O(n^c) for some constant c (e.g., O(n^2), O(n^3))
Exponential time: O(b^n) for some constant b (e.g., O(2^n))
